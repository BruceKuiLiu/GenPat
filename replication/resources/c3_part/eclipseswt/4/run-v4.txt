run cluster:4
PATTERN:
-	/**	 * Returns the current paint status object.	 * 	 * @return the current paint status object	 */	public PaintStatus getPaintStatus() {		return paintStatus;	}	/**	 * Returns the current paint tool.	 * 	 * @return the current paint tool, null if none is active (though some other session	 *         might be)	 */	public PaintTool getPaintTool() {		return (paintSession != null && paintSession instanceof PaintTool) ?			(PaintTool)paintSession : null;	}	/**	 * Returns the current position in an interactive operation.	 *	 * @return the last known position of the pointer	 */	public Point getCurrentPosition() {		return currentPosition;	}		/**	 * Redraws a specified rectangular area using the backing store	 * 	 * @param x the left X virtual coordinate of the region	 * @param y the top Y virtual coordinate of the region	 * @param width the width of the region	 * @param height the height of the region	 * @see getImageGC()	 */	public void redrawArea(int x, int y, int width, int height) {		// Clip to image and screen [computes intersection of the rectangles]		final int clipX = Math.max(imageRect.x, visibleRect.x);		if (x < clipX) {			width -= clipX - x;			x = clipX;		}		final int clipY = Math.max(imageRect.y, visibleRect.y);		if (y < clipY) {			height -= clipY - y;			y = clipY;		}		final int clipWidth = Math.min(imageRect.width, visibleRect.width) + clipX - x;		if (width > clipWidth) width = clipWidth;		final int clipHeight = Math.min(imageRect.height, visibleRect.height) + clipY - y;		if (height > clipHeight) height = clipHeight;		if (width < 0 || height < 0) return;				// Redraw the region		hideRubberband();		displayGC.drawImage(image, x - imageRect.x, y - imageRect.y, width, height,			x - visibleRect.x, y - visibleRect.y, width, height);		showRubberband();	}
-	/**	 * Draws a Figure object to the screen and to the backing store permanently.	 * 	 * @param object the object to draw onscreen	 */	public void drawFigure(Figure object) {		object.draw(getImageGC(), getImageOffset());		object.draw(getDisplayGC(), getDisplayOffset());	}	/**	 * Adds a Figure object to the active rubberband selection.	 * <p>	 * This object will be drawn to the screen as a preview and refreshed appropriately	 * until the selection is either cleared or committed.	 * </p>	 * 	 * @param object the object to add to the selection	 */	public void addRubberbandSelection(Figure object) {		if (isRubberbandHidden()) {			rubberband.add(object);		} else {			rubberbandState = rubberband.addAndPreview(object, rubberbandGC,				getDisplayOffset(), rubberbandState);		}	}	/**	 * Clears the active rubberband selection.	 * <p>	 * Erases any rubberband objects on the screen then clears the selection.	 * </p>	 */	public void clearRubberbandSelection() {		if (! isRubberbandHidden()) {			rubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);			rubberbandState = null;		}		rubberband.clear();	}	/**	 * Commits the active rubberband selection.	 * <p>	 * Redraws any rubberband objects on the screen as permanent objects then clears the selection.	 * </p>	 */	public void commitRubberbandSelection() {		if (! isRubberbandHidden()) {			rubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);			rubberbandState = null;		}		drawFigure(rubberband);		rubberband.clear();	}		/**	 * Hides the rubberband (but does not eliminate it).	 * <p>	 * Increments by one the rubberband "hide" nesting count.  The rubberband	 * is hidden from view (but remains active) if it wasn't already hidden.	 * </p>	 */	public void hideRubberband() {		if (rubberbandHiddenNestingCount++ <= 0) {			rubberband.erasePreview(rubberbandGC, getDisplayOffset(), rubberbandState);			rubberbandState = null;		}	}			/**	 * Shows (un-hides) the rubberband.	 * <p>	 * Decrements by one the rubberband "hide" nesting count.  The rubberband	 * is only made visible when showRubberband() has been called once for each	 * previous hideRubberband().  It is not permitted to call showRubberband() if	 * the rubber band is not presently hidden.	 * </p>	 */	public void showRubberband() {		if (rubberbandHiddenNestingCount <= 0)			throw new IllegalStateException("rubberbandHiddenNestingCount > 0");		if (--rubberbandHiddenNestingCount == 0) {			rubberbandState = rubberband.drawPreview(rubberbandGC, getDisplayOffset());		}	}		/**	 * Determines if the rubberband is hidden.	 * 	 * @return true iff the rubber is hidden	 */	public boolean isRubberbandHidden() {		return rubberbandHiddenNestingCount > 0;	}	/**	 * Displays the current position in the status bar.	 */	public void showCurrentPositionStatus() {		paintStatus.setCoord(currentPosition);	}	/**	 * Displays the current position in the status bar.	 */	public void showCurrentRangeStatus(Point anchorPosition) {		paintStatus.setCoordRange(anchorPosition, currentPosition);	}	/**	 * Handles a horizontal scroll event	 * 	 * @param scrollbar the horizontal scroll bar that posted this event	 */	public void scrollHorizontally(ScrollBar scrollBar) {		if (image == null) return;		if (imageRect.width > visibleRect.width) {			final int oldx = visibleRect.x;			visibleRect.x = Math.min(scrollBar.getSelection(), imageRect.width - visibleRect.width);			paintCanvas.scroll(Math.max(oldx - visibleRect.x, 0), 0, Math.max(visibleRect.x - oldx, 0), 0,				visibleRect.width, visibleRect.height, false);		}	}	/**	 * Handles a vertical scroll event	 * 	 * @param scrollbar the vertical scroll bar that posted this event	 */	public void scrollVertically(ScrollBar scrollBar) {		if (image == null) return;		if (imageRect.height > visibleRect.height) {			final int oldy = visibleRect.y;			visibleRect.y = Math.min(scrollBar.getSelection(), imageRect.height - visibleRect.height);			paintCanvas.scroll(0, Math.max(oldy - visibleRect.y, 0), 0, Math.max(visibleRect.y - oldy, 0),				visibleRect.width, visibleRect.height, false);		}	}		/**	 * Handles resize events	 */	private void handleResize() {		visibleRect = paintCanvas.getClientArea();		ScrollBar horizontal = paintCanvas.getHorizontalBar();		if (horizontal != null) {			visibleRect.x = Math.min(horizontal.getSelection(), imageRect.width - visibleRect.width);			if (imageRect.width <= visibleRect.width) {				horizontal.setEnabled(false);				horizontal.setSelection(0);			} else {				final int max = imageRect.width - visibleRect.width;				horizontal.setEnabled(true);				horizontal.setValues(visibleRect.x, 0, imageRect.width, visibleRect.width,					8, visibleRect.width);			}		}		ScrollBar vertical = paintCanvas.getVerticalBar();		if (vertical != null) {			visibleRect.y = Math.min(vertical.getSelection(), imageRect.height - visibleRect.height);			if (imageRect.height <= visibleRect.height) {				vertical.setEnabled(false);				vertical.setSelection(0);			} else {				final int max = imageRect.height - visibleRect.height;				vertical.setEnabled(true);				vertical.setValues(visibleRect.y, 0, imageRect.height, visibleRect.height,					8, visibleRect.height);			}		}	}	/**	 * Virtualizes MouseEvent coordinates and stores the current position.	 */	private void processMouseEventCoordinates(MouseEvent event) {		currentPosition.x = event.x =			Math.min(Math.max(event.x, 0), visibleRect.width - 1) + visibleRect.x;		currentPosition.y = event.y =			Math.min(Math.max(event.y, 0), visibleRect.height - 1) + visibleRect.y;	}}
+	/**	 * Returns the current paint tool.	 * 	 * @return the current paint tool, null if none is active (though some other session	 *         might be)	 */	public PaintTool getPaintTool() {		return (paintSession != null && paintSession instanceof PaintTool) ?			(PaintTool)paintSession : null;	}	/**	 * Returns the current position in an interactive operation.	 *	 * @return the last known position of the pointer	 */	public Point getCurrentPosition() {		return currentPosition;	}	/**	 * Draws a Figure object to the screen and to the backing store permanently.	 * 	 * @param object the object to draw onscreen	 */	public void drawFigure(Figure object) {		object.draw(imageFDC);		object.draw(displayFDC);	}	/**	 * Adds a Figure object to the active rubberband selection.	 * <p>	 * This object will be drawn to the screen as a preview and refreshed appropriately	 * until the selection is either cleared or committed.	 * </p>	 * 	 * @param object the object to add to the selection	 */	public void addRubberbandSelection(Figure object) {		rubberband.add(object);		if (! isRubberbandHidden()) object.draw(displayFDC);	}	/**	 * Clears the active rubberband selection.	 * <p>	 * Erases any rubberband objects on the screen then clears the selection.	 * </p>	 */	public void clearRubberbandSelection() {		if (! isRubberbandHidden()) {			Region region = new Region();			rubberband.addDamagedRegion(displayFDC, region);			Rectangle r = region.getBounds();			paintCanvas.redraw(r.x, r.y, r.width, r.height, true);			region.dispose();		}		rubberband.clear();	}	/**	 * Commits the active rubberband selection.	 * <p>	 * Redraws any rubberband objects on the screen as permanent objects then clears the selection.	 * </p>	 */	public void commitRubberbandSelection() {		rubberband.draw(imageFDC);		if (isRubberbandHidden()) rubberband.draw(displayFDC);		rubberband.clear();	}		/**	 * Hides the rubberband (but does not eliminate it).	 * <p>	 * Increments by one the rubberband "hide" nesting count.  The rubberband	 * is hidden from view (but remains active) if it wasn't already hidden.	 * </p>	 */	public void hideRubberband() {		if (rubberbandHiddenNestingCount++ <= 0) {			Region region = new Region();			rubberband.addDamagedRegion(displayFDC, region);			Rectangle r = region.getBounds();			paintCanvas.redraw(r.x, r.y, r.width, r.height, true);			region.dispose();		}	}			/**	 * Shows (un-hides) the rubberband.	 * <p>	 * Decrements by one the rubberband "hide" nesting count.  The rubberband	 * is only made visible when showRubberband() has been called once for each	 * previous hideRubberband().  It is not permitted to call showRubberband() if	 * the rubber band is not presently hidden.	 * </p>	 */	public void showRubberband() {		if (rubberbandHiddenNestingCount <= 0)			throw new IllegalStateException("rubberbandHiddenNestingCount > 0");		if (--rubberbandHiddenNestingCount == 0) {			rubberband.draw(displayFDC);		}	}		/**	 * Determines if the rubberband is hidden.	 * 	 * @return true iff the rubber is hidden	 */	public boolean isRubberbandHidden() {		return rubberbandHiddenNestingCount > 0;	}	/**	 * Handles a horizontal scroll event	 * 	 * @param scrollbar the horizontal scroll bar that posted this event	 */	public void scrollHorizontally(ScrollBar scrollBar) {		if (image == null) return;		if (imageWidth > visibleWidth) {			final int oldx = displayFDC.xOffset;			displayFDC.xOffset = Math.min(scrollBar.getSelection(), imageWidth - visibleWidth);			paintCanvas.scroll(Math.max(oldx - displayFDC.xOffset, 0), 0, Math.max(displayFDC.xOffset - oldx, 0), 0,				visibleWidth, visibleHeight, false);		}	}	/**	 * Handles a vertical scroll event	 * 	 * @param scrollbar the vertical scroll bar that posted this event	 */	public void scrollVertically(ScrollBar scrollBar) {		if (image == null) return;		if (imageHeight > visibleHeight) {			final int oldy = displayFDC.yOffset;			displayFDC.yOffset = Math.min(scrollBar.getSelection(), imageHeight - visibleHeight);			paintCanvas.scroll(0, Math.max(oldy - displayFDC.yOffset, 0), 0, Math.max(displayFDC.yOffset - oldy, 0),				visibleWidth, visibleHeight, false);		}	}		/**	 * Handles resize events	 */	private void handleResize() {		Rectangle visibleRect = paintCanvas.getClientArea();		visibleWidth = visibleRect.width;		visibleHeight = visibleRect.height;		ScrollBar horizontal = paintCanvas.getHorizontalBar();		if (horizontal != null) {			displayFDC.xOffset = Math.min(horizontal.getSelection(), imageWidth - visibleWidth);			if (imageWidth <= visibleWidth) {				horizontal.setEnabled(false);				horizontal.setSelection(0);			} else {				final int max = imageWidth - visibleWidth;				horizontal.setEnabled(true);				horizontal.setValues(displayFDC.xOffset, 0, imageWidth, visibleWidth,					8, visibleWidth);			}		}		ScrollBar vertical = paintCanvas.getVerticalBar();		if (vertical != null) {			displayFDC.yOffset = Math.min(vertical.getSelection(), imageHeight - visibleHeight);			if (imageHeight <= visibleHeight) {				vertical.setEnabled(false);				vertical.setSelection(0);			} else {				final int max = imageHeight - visibleHeight;				vertical.setEnabled(true);				vertical.setValues(displayFDC.yOffset, 0, imageHeight, visibleHeight,					8, visibleHeight);			}		}	}	/**	 * Virtualizes MouseEvent coordinates and stores the current position.	 */	private void processMouseEventCoordinates(MouseEvent event) {		currentPosition.x = event.x =			Math.min(Math.max(event.x, 0), visibleWidth - 1) + displayFDC.xOffset;		currentPosition.y = event.y =			Math.min(Math.max(event.y, 0), visibleHeight - 1) + displayFDC.yOffset;	}		/**	 * Clears the status bar.	 */	public void clearStatus() {		statusActionInfo = "";		statusMessageInfo = "";		statusCoordInfo = "";		updateStatus();	}	/**	 * Sets the status bar action text.	 *	 * @param action the action in progress, null to clear	 */	public void setStatusAction(String action) {		statusActionInfo = (action != null) ? action : "";		updateStatus();	}		/**	 * Sets the status bar message text.	 * 	 * @param message the message to display, null to clear	 */	public void setStatusMessage(String message) {		statusMessageInfo = (message != null) ? message : "";		updateStatus();	}	/**	 * Sets the coordinates in the status bar.	 * 	 * @param coord the coordinates to display, null to clear	 */	public void setStatusCoord(Point coord) {		statusCoordInfo = (coord != null) ? PaintPlugin.getResourceString("status.Coord.format", new Object[]			{ new Integer(coord.x), new Integer(coord.y)}) : "";		updateStatus();	}	/**	 * Sets the coordinate range in the status bar.	 * 	 * @param a the "from" coordinate, must not be null	 * @param b the "to" coordinate, must not be null	 */	public void setStatusCoordRange(Point a, Point b) {		statusCoordInfo = PaintPlugin.getResourceString("status.CoordRange.format", new Object[]			{ new Integer(a.x), new Integer(a.y), new Integer(b.x), new Integer(b.y)});		updateStatus();	}	/**	 * Updates the display.	 */	private void updateStatus() {		statusText.setText(			PaintPlugin.getResourceString("status.Bar.format", new Object[]			{ statusActionInfo, statusMessageInfo, statusCoordInfo }));	}}

TP, FP = 0,0
original_before=
public void scrollHorizontally(ScrollBar scrollBar){
if(image==null){
return ;
}
if(imageRect.width>visibleRect.width){
 final int oldx=visibleRect.x;
visibleRect.x=Math.min(scrollBar.getSelection(),imageRect.width-visibleRect.width);
paintCanvas.scroll(Math.max(oldx-visibleRect.x,0),0,Math.max(visibleRect.x-oldx,0),0,visibleRect.width,visibleRect.height,false);
}
}
